import {viewSlugify} from 'd3-view';
import express from 'express';
import {join} from 'path';
import {existsSync, readFileSync} from 'fs';
import {JSDOM} from 'jsdom';

import extractMetadata from '../utils/meta';

//
//  Serve markdown pages matching a pattern


export default function (app, siteConfig) {
    if (!siteConfig.markdown) return;
    const plugins = siteConfig.markdown.plugins;

    Object.keys(siteConfig.markdown).forEach(key => {

        if (key !== 'plugins') {
            const path = viewSlugify(key);
            app.use('/${path}', markdown(key, siteConfig.markdown[key], plugins, siteConfig));
        }

    });

}


function docTemplate (ctx) {

    return (`
        <!DOCTYPE html>
        <html>
        <head>
            <title>${ctx.title}</title>
            <meta charset="utf-8">
            <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1">
            <meta name="viewport" content="width=device-width, initial-scale=1">
            <link href="/static/admin.css" media="all" rel="stylesheet" />
        </head>
        <body>
            <div id="root" d3-meta='${ctx.metadata}'>
                <marked>${ctx.content}</marked>
            </div>
            <script src="/static/admin.js"></script>
        </body>
        </html>
    `);
}


function renderDoc (ctx) {
    ctx.metadata = JSON.stringify(ctx.metadata);
    const dom = new JSDOM(
        docTemplate(ctx),
        {runScripts: "dangerously"}
    );
    return dom.serialize();
}


function markdown (key, config, plugins, siteConfig) {
    plugins = [].concat(plugins || []);
    if (config.plugins) plugins = plugins.concat(config.plugins);

    const app = express();

    app.get('/:name', (req, res, next) => {
        let file = join(key, req.params.name);

        if (!existsSync(file)) {
            file = `${file}.md`;
            if (!existsSync(file)) {
                next();
                return;
            }
        }

        let ctx = extractMetadata(readFileSync(file, 'utf8'));

        // generate table of contents if appropriate
        if (ctx.content && raw.content.indexOf(TABLE_OF_CONTENTS_TOKEN) !== -1) {
            ctx.content = insertTableOfContents(raw.content);
        }

        return app.send(renderDoc(ctx));
    });
}


const TABLE_OF_CONTENTS_TOKEN = '<AUTOGENERATED_TABLE_OF_CONTENTS>';


function insertTableOfContents (rawContent) {
    const regexp = /\n###\s+(`.*`.*)\n/g;
    let match;
    const headers = [];
    while ((match = regexp.exec(rawContent))) {
        headers.push(match[1]);
    }

    const tableOfContents = headers
      .map(header => `  - [${header}](#${toSlug(header)})`)
      .join('\n');

    return rawContent.replace(TABLE_OF_CONTENTS_TOKEN, tableOfContents);
}

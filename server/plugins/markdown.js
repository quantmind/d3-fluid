import express from 'express';
import {existsSync, readFileSync} from 'fs';
import {join} from 'path';
import {compile} from 'handlebars';
import {viewSlugify} from 'd3-view';
import {pop} from 'd3-let';

// import {JSDOM} from 'jsdom';
import extractMetadata from '../utils/meta';
import debug from '../utils/debug';
import {resolve} from '../utils/path';


//
//  Serve markdown pages matching a pattern
export default function (app, siteConfig) {
    if (!siteConfig.markdown) return;

    const
        plugins = siteConfig.markdown.plugins,
        paths = siteConfig.markdown.paths || [];

    paths.forEach(cfg => {
        const slug = cfg.slug || '';
        app.use(`/${slug}`, markdown(cfg, plugins, siteConfig));
    });

}


function docTemplate (ctx, siteConfig) {
    const css = siteConfig.stylesheets.map(stylesheet => {
        return `<link href="${stylesheet}" media="all" rel="stylesheet" />`;
    }).join('\n');
    const scripts = siteConfig.scripts.map(script => {
        return `<script src="${script}"></script>`;
    }).join('\n');
    const bodyExtra = siteConfig.bodyExtra.join('\n');
    const content = pop(ctx, 'content').trim();
    ctx = JSON.stringify(ctx);
    //
    // get outer template

    return (`
        <!DOCTYPE html>
        <html>
        <head>
            <title>${ctx.title}</title>
            <meta charset="utf-8">
            <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1">
            <meta name="viewport" content="width=device-width, initial-scale=1">
            ${css}
            <script>var config='${ctx}'</script>
        </head>
        <body>
            <div id="root">
                <fluid-content>${content}</fluid-content>
            </div>
            ${scripts}
            ${bodyExtra}
        </body>
        </html>
    `);
}


function renderDoc (ctx, siteConfig) {
    ctx.metadata = JSON.stringify(ctx.metadata);
    return docTemplate(ctx, siteConfig);
    //const dom = new JSDOM(
    //    docTemplate(ctx),
    //    {runScripts: "dangerously"}
    //);
    //return dom.serialize();
}


function markdown (ctx, plugins, siteConfig) {

    const app = express();

    app.get('/', (req, res, next) => {
        tryFile('index', res, next);
    });

    app.use('/:name', (req, res, next) => {
        tryFile(req.params.name, res, next);
    });

    debug('Markdown micro-site');
    debug(ctx);

    return app;

    function tryFile (name, res, next) {
        let path = resolve(siteConfig.path, ctx.path),
            file = join(path, name),
            ext = file.split('.').pop();
        debug(`try loading from "${file}"`);

        let render = false;
        if (!existsSync(file)) {
            file = `${file}.md`;
            render = true;
            if (!existsSync(file)) {
                next();
                return;
            }
        }

        ext = file.split('.').pop();
        let text = readFileSync(file, 'utf8');

        if (ext === 'md') {
            const context = Object.assign({}, ctx, extractMetadata(text));

            // generate table of contents if appropriate
            if (context.content) {
                context.content = compile(context.content)(context);

                if (context.content.indexOf(TABLE_OF_CONTENTS_TOKEN) !== -1)
                    context.content = insertTableOfContents(context.content);
            }
            if (render) text = renderDoc(context, siteConfig);
            else {
                res.setHeader('Content-Type', 'application/json');
                text = JSON.stringify(context);
            }
        }
        return res.send(text);
    }
}


const TABLE_OF_CONTENTS_TOKEN = '<AUTOGENERATED_TABLE_OF_CONTENTS>';


function insertTableOfContents (rawContent) {
    const regexp = /\n###\s+(`.*`.*)\n/g;
    let match;
    const headers = [];
    while ((match = regexp.exec(rawContent))) {
        headers.push(match[1]);
    }

    const tableOfContents = headers
        .map(header => `  - [${header}](#${viewSlugify(header)})`)
        .join('\n');

    return rawContent.replace(TABLE_OF_CONTENTS_TOKEN, tableOfContents);
}
